<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/*
Queueing part is cited from: 
"Automatic Verification of Real-Time Communicating Systems by Constraint Solving", 
by Wang Yi, Paul Pettersson and Mats Daniels. In Proceedings of the 7th International
Conference on Formal Description Techniques, pages 223-238, North-Holland. 1994.

This week:
- Started rearchitecturing templates for easier time and statistical verification (packet as template)
- Added multiple packets mechanism
- Added shared queue to switch

TODO:
- Add client that does sliding window
- Add time to packets (upper bound as invariant, lower bound as guard)
- Add statistical verification 
- NetDice static routes
- Parameterization
*/

const int N = 6;   // # packet
const int E = 30; // # entity
// 0 -&gt; link / network
// 1-9 -&gt; nodes
// 10-19 -&gt; link
// 20-30 -&gt; switch

typedef int[0,N-1] id_t;
typedef int[0,E-1] eid_t;

broadcast chan        appr[E][N], leave[E][N], drop[N];
</declaration>
	<template>
		<name>Link</name>
		<parameter>const eid_t id</parameter>
		<declaration>clock t;
id_t temp;</declaration>
		<location id="id0" x="-357" y="-17">
			<name x="-399" y="-25">A</name>
		</location>
		<location id="id1" x="-204" y="-17">
			<name x="-229" y="-51">on_link</name>
			<label kind="invariant" x="-221" y="0">t &lt; 5</label>
		</location>
		<branchpoint id="id2" x="-59" y="-17">
		</branchpoint>
		<init ref="id0"/>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="-144" y="-42">t &gt;= 1</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="select" x="-340" y="-76">p : id_t</label>
			<label kind="synchronisation" x="-340" y="-59">appr[id][p]?</label>
			<label kind="assignment" x="-340" y="-42">temp=p, t=0</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-340" y="34">leave[id][temp]!</label>
			<label kind="probability" x="-339" y="51">9</label>
			<nail x="-59" y="34"/>
			<nail x="-357" y="34"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-340" y="-127">drop[temp]!</label>
			<label kind="probability" x="-340" y="-144">1</label>
			<nail x="-59" y="-93"/>
			<nail x="-357" y="-93"/>
		</transition>
	</template>
	<template>
		<name>ProbTest</name>
		<declaration>clock t;</declaration>
		<location id="id3" x="-187" y="0">
			<name x="-197" y="-34">choose</name>
			<label kind="invariant" x="-197" y="17">t &lt; 2</label>
		</location>
		<location id="id4" x="51" y="-246">
			<name x="41" y="-280">success</name>
			<label kind="invariant" x="41" y="-229">t &lt; 2</label>
		</location>
		<location id="id5" x="59" y="221">
			<name x="49" y="187">fail</name>
			<label kind="invariant" x="49" y="238">t &lt; 2</label>
		</location>
		<location id="id6" x="-340" y="0">
			<name x="-350" y="-34">initi</name>
		</location>
		<branchpoint id="id7" x="-42" y="0">
		</branchpoint>
		<init ref="id6"/>
		<transition>
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="-322" y="76">t &gt;= 1</label>
			<label kind="assignment" x="-322" y="110">t=0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id6"/>
			<label kind="guard" x="-322" y="-157">t &gt;= 1</label>
			<label kind="synchronisation" x="-322" y="-140">leave[0][0]!</label>
			<label kind="assignment" x="-322" y="-123">t=0</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-297" y="-25">appr[0][0]?</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id7"/>
			<label kind="guard" x="-119" y="-25">t &gt;= 1</label>
			<label kind="assignment" x="-119" y="0">t = 0</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="probability" x="-17" y="17">1</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id4"/>
			<label kind="probability" x="-17" y="-25">4</label>
		</transition>
	</template>
	<template>
		<name x="40" y="16">Packet</name>
		<parameter>const id_t id, int src, int dst</parameter>
		<declaration>// TODO: how to parameterize this?

clock t;
clock total;

int[0,2] type;

int next_hop;

eid_t getNextHop(eid_t curLoc, id_t dst) {
    eid_t forwarding[5]; // forwarding[i] == next_hop to reach node i

    if (curLoc == 1) {
        forwarding[1] = 1;
        forwarding[2] = 20; // change to port number
        forwarding[3] = 20;
        forwarding[4] = 20;
    } else if (curLoc == 2) {
        forwarding[1] = 20;
        forwarding[2] = 2;
        forwarding[3] = 20;
        forwarding[4] = 20;
    } else if (curLoc == 3) {
        forwarding[1] = 21;
        forwarding[2] = 21;
        forwarding[3] = 3;
        forwarding[4] = 21;
    } else if (curLoc == 4) {
        forwarding[1] = 21;
        forwarding[2] = 21;
        forwarding[3] = 21;
        forwarding[4] = 4;
    } else if (curLoc == 20) {
        forwarding[1] = 1;
        forwarding[2] = 2;
        forwarding[3] = 21;
        forwarding[4] = 21;
    } else if (curLoc == 21) {
        forwarding[1] = 20;
        forwarding[2] = 20;
        forwarding[3] = 3;
        forwarding[4] = 4;
    }

    return forwarding[dst];
}</declaration>
		<location id="id8" x="-246" y="-212">
			<name x="-340" y="-221">on_sender</name>
			<label kind="invariant" x="-263" y="-195">t &lt; 2</label>
		</location>
		<location id="id9" x="59" y="-212">
			<name x="42" y="-195">on_link</name>
		</location>
		<location id="id10" x="59" y="-450">
			<name x="34" y="-493">on_switch</name>
		</location>
		<location id="id11" x="391" y="-212">
			<name x="417" y="-221">on_receiver</name>
		</location>
		<location id="id12" x="17" y="-331">
			<committed/>
		</location>
		<location id="id13" x="93" y="-331">
			<committed/>
		</location>
		<init ref="id8"/>
		<transition>
			<source ref="id13"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="93" y="-280">appr[0][id]!</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id13"/>
			<label kind="guard" x="102" y="-450">t &gt;= 1</label>
			<label kind="synchronisation" x="102" y="-433">leave[next_hop][id]?</label>
			<label kind="assignment" x="102" y="-416">next_hop = getNextHop(next_hop, dst)</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-102" y="-416">appr[next_hop][id]!</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id12"/>
			<label kind="guard" x="-136" y="-297">next_hop &gt;= 10 &amp;&amp;
t &gt;= 1</label>
			<label kind="synchronisation" x="-136" y="-263">leave[0][id]?</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id11"/>
			<label kind="guard" x="119" y="-204">next_hop &lt; 10 &amp;&amp;
t &gt;= 1</label>
			<label kind="synchronisation" x="119" y="-161">leave[0][id]?</label>
			<label kind="assignment" x="119" y="-144">next_hop = getNextHop(next_hop, dst)</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id9"/>
			<label kind="guard" x="-204" y="-204">t &gt;= 1</label>
			<label kind="synchronisation" x="-204" y="-186">appr[0][id]!</label>
			<label kind="assignment" x="-204" y="-170">next_hop = getNextHop(src,dst),
total = 0,
t = 0</label>
		</transition>
	</template>
	<template>
		<name>PacketMock</name>
		<parameter>const id_t id, int src, int dst</parameter>
		<declaration>// TODO: how to parameterize this?

clock t;</declaration>
		<location id="id14" x="-323" y="-25">
			<label kind="exponentialrate" x="-333" y="9">1</label>
		</location>
		<location id="id15" x="-229" y="-25">
			<name x="-238" y="-8">on_link</name>
		</location>
		<location id="id16" x="-136" y="-25">
			<committed/>
		</location>
		<location id="id17" x="-51" y="-25">
			<name x="-68" y="-8">on_switch</name>
		</location>
		<location id="id18" x="42" y="-25">
			<name x="76" y="-42">on_receiver</name>
		</location>
		<init ref="id14"/>
		<transition>
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-42" y="-68">leave[20][id]?</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-136" y="-68">appr[20][id]!</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-229" y="-68">leave[0][id]?</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-323" y="-68">appr[0][id]!</label>
			<label kind="assignment" x="-306" y="-51">t=0</label>
		</transition>
	</template>
	<template>
		<name x="40" y="16">Switch</name>
		<parameter>const eid_t id</parameter>
		<declaration>const int qsize = 5;

clock t;

id_t temp; // for holding incoming packets

id_t list[qsize+1];
int[0,qsize] len;

// Put an element at the end of the queue
void enqueue(id_t element)
{
        list[len++] = element;
}

// Remove the front element of the queue
void dequeue()
{
        int i = 0;
        len -= 1;
        while (i &lt; len)
        {
                list[i] = list[i + 1];
                i++;
        }
        list[i] = 0;
}

// Returns the front element of the queue
id_t front()
{
   return list[0];
}

// Returns the last element of the queue
id_t tail()
{
   return list[len - 1];
}</declaration>
		<location id="id19" x="161" y="-314">
			<name x="119" y="-323">idle</name>
			<label kind="exponentialrate" x="144" y="-289">1</label>
		</location>
		<location id="id20" x="306" y="-314">
			<name x="323" y="-323">received</name>
			<committed/>
		</location>
		<location id="id21" x="-59" y="-314">
			<label kind="invariant" x="-119" y="-323">t &lt; 4</label>
		</location>
		<init ref="id19"/>
		<transition>
			<source ref="id21"/>
			<target ref="id19"/>
			<label kind="guard" x="0" y="-246">t &gt;= 1</label>
			<label kind="synchronisation" x="0" y="-229">leave[id][front()]!</label>
			<label kind="assignment" x="0" y="-212">dequeue(),
t=0</label>
			<nail x="42" y="-255"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="guard" x="25" y="-433">len &gt; 0 &amp;&amp;
t &gt;= 1</label>
			<label kind="assignment" x="25" y="-450">t = 0</label>
			<nail x="42" y="-382"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="guard" x="187" y="-297">len + 1 &lt;= qsize</label>
			<label kind="assignment" x="187" y="-280">enqueue(temp)</label>
			<nail x="306" y="-255"/>
			<nail x="161" y="-255"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="guard" x="195" y="-425">len + 1 &gt; qsize</label>
			<label kind="synchronisation" x="195" y="-408">drop[temp]!</label>
			<nail x="306" y="-382"/>
			<nail x="161" y="-382"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="select" x="195" y="-374">e : id_t</label>
			<label kind="synchronisation" x="195" y="-357">appr[id][e]?</label>
			<label kind="assignment" x="195" y="-340">temp=e</label>
		</transition>
	</template>
	<template>
		<name>ProbTestDriver</name>
		<declaration>clock t;</declaration>
		<location id="id22" x="-238" y="-17">
			<name x="-248" y="-51">start</name>
			<label kind="invariant" x="-248" y="0">t &lt; 2</label>
		</location>
		<location id="id23" x="-25" y="-17">
			<name x="-35" y="-51">prob</name>
		</location>
		<location id="id24" x="161" y="-17">
			<name x="151" y="-51">mid</name>
			<label kind="invariant" x="151" y="0">t &lt; 2</label>
		</location>
		<location id="id25" x="323" y="-17">
			<name x="313" y="-51">prob2</name>
		</location>
		<location id="id26" x="501" y="-17">
			<name x="491" y="-51">end</name>
		</location>
		<init ref="id22"/>
		<transition>
			<source ref="id25"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="374" y="-68">leave[0][0]?</label>
			<label kind="assignment" x="391" y="-8">t=0</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id25"/>
			<label kind="guard" x="195" y="-51">t &gt;= 1</label>
			<label kind="synchronisation" x="195" y="-68">appr[0][0]!</label>
			<label kind="assignment" x="195" y="-17">t=0</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="34" y="-68">leave[0][0]?</label>
			<label kind="assignment" x="34" y="-8">t=0</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id23"/>
			<label kind="guard" x="-178" y="-51">t &gt;= 1</label>
			<label kind="synchronisation" x="-178" y="-68">appr[0][0]!</label>
			<label kind="assignment" x="-161" y="-8">t = 0</label>
		</transition>
	</template>
	<system>//P1 = Packet(1, 1, 4);
//S20 = Switch(20);
//S21 = Switch(21);
//Net = Link(0);
//system P1, S20, S21, Net;

system ProbTest, ProbTestDriver;

/*gantt {
  G: // gate line
     Switch.len&gt;0 -&gt; 2+17*(Switch.len-1)/2; // shade of blue
  T(i:id_t): // train lines
     //Train(i).Safe -&gt; 3, // violet, or omit for white
     Packet(i).Appr -&gt; 6, // yellow
     Packet(i).Stop -&gt; 1, // green
     Packet(i).Start -&gt; 2, // blue
     Packet(i).Cross -&gt; 0; // red
   //C(i:int[0,64]): true -&gt; i; // color palette
}*/</system>
	<queries>
		<query>
			<formula>Pr[# &lt;= 30; 10000](&lt;&gt; P1.on_receiver)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[P1.t &lt;= 25; 10000](&lt;&gt; P1.on_receiver)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>simulate[P1.t&lt;=10]{P1.t}</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[# &lt;= 2; 10000](&lt;&gt; ProbTest.success)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[# &lt;= 10; 10000](&lt;&gt; ProbTestDriver.end)</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>simulate[&lt;=100]{ Train(0).x, Gate.len }</formula>
			<comment>Plot the change in the clock x and the queue length over time.
Expect two trajectories from one simulation of up to 100 time units.</comment>
		</query>
		<query>
			<formula>simulate[&lt;=100; 10]{ Train(0).x, Gate.len }</formula>
			<comment>Plot the change in the clock x and the queue length over time.
Expect 10+10 trajectories from 10 simulations of up to 100 time units.</comment>
		</query>
		<query>
			<formula>simulate[&lt;=100]{ sum(i:id_t) Train(i).Stop }</formula>
			<comment>Count the trains that are stopped over time.
Expect one trajectory from one simulation.</comment>
		</query>
		<query>
			<formula>E[&lt;=100](max: sum(i:id_t) Train(i).Stop)</formula>
			<comment>Compute an expected maximum value of trains being stopped.
Expect a mean estimate based on two samples
(one statistical degree of freedom, assuming Student's t-distribution).</comment>
		</query>
		<query>
			<formula>E[&lt;=100; 2000](max: sum(i:id_t) Train(i).Stop)</formula>
			<comment>Compute an expected maximum value of trains being stopped.
Expect a mean estimate based on 2000 samples (assuming Student's t-distribution).</comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(0).Cross)</formula>
			<comment>Estimate the probability that the train arrives to the crossing before 100 time units.</comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(1).Cross)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(2).Cross)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(3).Cross)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(4).Cross)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(5).Cross)</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100; 400](&lt;&gt; Train(5).Cross)</formula>
			<comment>Estimate the probability of the train arriving to the crossing before 100 time units.
Expect more precise estimate (and more refined distribution plots) from 400 simulation runs.</comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(0).Cross and (forall(i : id_t) i != 0 imply Train(i).Stop))</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(1).Cross and (forall(i : id_t) i != 1 imply Train(i).Stop))
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(2).Cross and (forall(i : id_t) i != 2 imply Train(i).Stop))</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(3).Cross and (forall(i : id_t) i != 3 imply Train(i).Stop))</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(4).Cross and (forall(i : id_t) i != 4 imply Train(i).Stop))</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=100](&lt;&gt; Train(5).Cross and (forall(i : id_t) i != 5 imply Train(i).Stop))</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[&lt;=600](&lt;&gt; Train(1).Cross and (forall(i : id_t) i != 1 imply Train(i).Stop)) &gt;=
Pr[&lt;=600](&lt;&gt; Train(5).Cross and (forall(i : id_t) i != 5 imply Train(i).Stop))</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr[#&lt;=20]([] 
  forall(i : id_t) 
    forall(j : id_t) 
      Train(i).Cross &amp;&amp; Train(j).Cross imply i == j
) &gt;= 0.98</formula>
			<comment>Check that within 20 discrete transition the probability of no colision 
(no two trains in the crossing) is larger than 98%.</comment>
		</query>
		<query>
			<formula></formula>
			<comment>===== Validation Properties:</comment>
		</query>
		<query>
			<formula>E&lt;&gt; Gate.Occ</formula>
			<comment>Gate can receive (and store in queue) msg's from approaching trains.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; Train(0).Cross</formula>
			<comment>Train 0 can reach crossing.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; Train(1).Cross	</formula>
			<comment>Train 1 can reach crossing.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; Train(0).Cross and Train(1).Stop</formula>
			<comment>Train 0 can be crossing bridge while Train 1 is waiting to cross.</comment>
		</query>
		<query>
			<formula>E&lt;&gt; Train(0).Cross and (forall (i : id_t) i != 0 imply Train(i).Stop)</formula>
			<comment>Train 0 can cross bridge while the other trains are waiting to cross.</comment>
		</query>
		<query>
			<formula></formula>
			<comment>===== Safety Properties:</comment>
		</query>
		<query>
			<formula>A[] forall (i : id_t) forall (j : id_t) Train(i).Cross &amp;&amp; Train(j).Cross imply i == j</formula>
			<comment>There is never more than one train crossing the bridge (at
any time instance).</comment>
		</query>
		<query>
			<formula>A[] Gate.list[N] == 0</formula>
			<comment>There can never be N elements in the queue (thus the array will not overflow).</comment>
		</query>
		<query>
			<formula></formula>
			<comment>===== Liveness Properties:</comment>
		</query>
		<query>
			<formula>Train(0).Appr --&gt; Train(0).Cross</formula>
			<comment>Whenever a train approaches the bridge, it will eventually cross.</comment>
		</query>
		<query>
			<formula>Train(1).Appr --&gt; Train(1).Cross</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Train(2).Appr --&gt; Train(2).Cross</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Train(3).Appr --&gt; Train(3).Cross</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Train(4).Appr --&gt; Train(4).Cross</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Train(5).Appr --&gt; Train(5).Cross</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
